npm create vite@latest NA PASTA QUE VAI CRIAR A PASTA DO PROJETO
npm i
remove read.me, icon no html, eslint, eslint nas dependencias, assets -> npm i p apagar tudo
remove css, colcoa export default pra exportacao nomeada

git init - ja deixa tudo verdinho dizendo que vai mudar quando commitar la no repo, 
e ja fica tbm apagadinho os arquivos que sao do gitignore

- shadcn ui
componentes padronizados que foram pegos do radix por exemplo, que eh uma biblioteca com componentes puros, sem estilziacao

fazer esses comandos:

[Vite - shadcn/ui](https://ui.shadcn.com/docs/installation/vite)

pra importar componentes, tem que importar um por um, a pasta componentes vem vazia.


- eslint - 
instalando eslint e o eslint da rocketseat
npm i eslint @rocketseat/eslint-config -D
.eslintrc.json

{
    "extends": ["@rocketseat/eslint-config/react"],
}

instalar prettier: [tailwindlabs/prettier-plugin-tailwindcss: A Prettier plugin for Tailwind CSS that 
automatically sorts classes based on our recommended class order. (github.com)](https://github.com/tailwindlabs/prettier-plugin-tailwindcss)

npm i -D prettier nao precisa pois ja tem no rocketseat eslint

npm i -D prettier-plugin-tailwindcss

criar arquivo prettier.config.ts

reload window vscode

se tiver que usar o module.exports nesse arquivo prettier pq ele ainda nao suport 
aquele exports default, entao trocar a extensao do arquivo pra cjs

plugin eslint-plugin-simple-import-sort: [lydell/eslint-plugin-simple-import-sort: 
Easy autofixable import sorting. (github.com)](https://github.com/lydell/eslint-plugin-simple-import-sort)


---
instalando react router dom
n estamos usando next, remix, astro, entao n temos estrutura pronta de roteamento. e 
como o react eh uma biblioteca de construcao de interface, ele nao tras consigo 
uma funcionaidade de rotas, paginas. Basicamente eh tudo uma unica pagina so

[Tutorial v6.22.3 | React Router](https://reactrouter.com/en/main/start/tutorial)

----------------------------------------------------------------
layouts - tanto a parte de auth quanto a de app vao ter componentes em comum,
por ex, cadastro e login na parte de auth, vao ter partes em comuns. e no app,
todas as paginas vao ter cabecalho, rodape, etc.

outlet eh o componente p especfiicar aonde que vai entrar o que eh
especifico de cada pagina. ou seja, o q nao eh comum entre as paginas.

nas rotas, em cada rota agora fica no element o layout referente. como 
children, vamos colocar as rotas que usarao aquele layout, que eh o outlet

react-helmet-async para colocar titulos dinamicos em cada pagina
(Login | pizza.shop) - Login eh dinamico e pizza.shop eh estatico

- login page
-layout com a parte da esquerda
pagina sign-in
 - title do helmet pega a parte %2 q fizemos no layout
 - label e input sao do shadcn-ui(px shadcn-ui@latest add input label)
 - troca de tema - https://ui.shadcn.com/themes - copiar o codigo e colar em global.css


- react hook form
npm i react-hook-form zod @hookform/resolvers
zod p validacao e transformacao de dados
hookform resolver -integracao do react-hook-form com as libs de validacao(zod no caso)

-import useForm
- const { register, handleSubmit} = useForm() 
  -register p registrar campso no formulario - jogar no input
  -handleSubmit - lidar com submit do formulario(ja lida com a parte de propagacao,
  n precisa de prevent default)
  high order funciton(pattern) - vamos usar o handlesubmit do useForm p chamar a funcao 
  handleSignIn()
- usar zod pra validacao 
   -z.object - quando usuario fizer submit, vai mandar o email atraves do register:

        <Input id="email" type="email" {...register('email')} />

   para o handleSignIn atraves do handleSubmit:

        <form className="space-y-4" onSubmit={handleSubmit(handleSignIn)}>
    
    essa funcao recebe um email, que eh uma string, entao vamos validar:

        const signInForm = z.object({
            email: z.string().email(),
        })

    vamos tambem tipar

        type SignInForm = z.infer<typeof signInForm>

    e agora, o handleSignIn vai receber esse signInForm(que no momento tem so um email que eh string)

        async function handleSignIn(data: SignInForm)

    data vai ficar no formato - { email: 'rodrigo@outlook.com'}


-formState do useForm:
    formState: { isSubmitting },
esse isSubmitting eh true esta carregnado, em estado de submit
eh false quando deu erro ou sucesso, quando nao ta carregnad, quando usuario n clicou

ai usa pra boolear o disabled do botao
<Button disabled={isSubmitting} className="w-full" type="submit">


-TOAST da lib sonner
 -facilita msgs de sucesso e erro pro usuario.
 - podemos colocar mais um parametro pra estilizar mais, com o "action" por exemplo


- pagina de cadastro

signUp eh parecido com a signIn
- selecionar signIn, ctrl + shift + p, selecionar "replace" escreve signUp,
- clicar para preservar case, ou seja, o signIn vai ficar signUp e SignIn fica SignUp

nas rotas de Auth, colocar mais um path no children, dessa vez para o signUp
        {
          path: '/sign-un',
          element: <SignUp />,
        },


- na div do outlet no authLayout, vamos colocar relative, e entao no SignUp, vamos poder
colocar um link usando position absolute

no SignUp - botao pra ir pro SignIn
<Button variant="ghost" asChild className="absolute right-8 top-8">
          <Link to="/sign-in">Fazer login</Link>
</Button>

e no SignIn, botao p ir pro SignUp 
<Button variant="ghost" asChild className="absolute right-8 top-8">
          <Link to="/sign-up">Novo estabelecimento</Link>
</Button>
esse link funciona como uma ancora, mas n faz reload total da pagina

---criar mais campos pra esse SignUp ---

-alterar a validacao
const signUpForm = z.object({
  restaurantName: z.string(),
  managerName: z.string(),
  phone: z.string(),
  email: z.string().email(),
})

-criar mais input com labels e registers
<div className="space-y-2">
    <Label htmlFor="xxx">xxxx</Label>
    <Input id="xxx" type="xxx" {...register('xxx')} />
</div>

-toast alterado para sucesso no caso de restaraunte cadastro
-no action, podemos fazer um botao "login", que ao clicado, redireciona
para a pagina de login(pois o usuario ja tem conta agora)
pra isso, vamos usar useNavigate


import { Link, useNavigate } from 'react-router-dom'
const navigate = useNavigate()

toast.success('Restaurante cadastrado com sucesso!', {
        action: {
          label: 'Login',
          onClick: () => navigate('/sign-in'),
        },
      })


----layout do app com cabecalho
app layouts
flex min h screen p ocupar no minimo a altura da tela toda

flex flex-1 - p ocupar a altura da tela toda tirando a altura do cabecalho

header
border-b - borda de separacao c cabecalho

npx shadcn-ui@latest add separator
pra usar o Separator - uma linha vertical ou horizontal

lg:space-x-6 - em caso de telas maiores


criar componente de links, ate pq vms querer botar estilizacao especifica e
um compoortamento, de que o icone ativo, fique em negrito, diferente do outro

pra poder extender as propriedades de um link do react router dom
export type NavLinkProps = LinkProps

deixar aquele link em negrito p sinalizar que esta na pagina dele:
useLocation do react-router-dom
const { pathname } = useLocation()

se o pathname for igual a rota atual:
data-current={pathname === props.to}
entao retorna true.

se for true, estilize:
data-[current=true]:text-foreground


---dark mode
colar o codigo pronto pro vite la no shadcnui
codigo do botao tbm

npx shadcn-ui@latest add dropdown-menu

-------------------------------------------------


usando a api - bun - Windows Subsystem for Linux (WSL)
https://github.com/rocketseat-education/pizzashop-api
https://learn.microsoft.com/en-us/windows/wsl/install
https://bun.sh/docs/installation
https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-vscode


wsl --install
wsl --install -d Ubuntu

instalando bun 
curl -fsSL https://bun.sh/install | bash 

pra entrar no terminal referente a esse wsl, digitar wsl no terminal

ao clonar a api, dar um code . com o wsl ^ligado^

https://educoutinho.com.br/windows/instalando-docker-no-wsl/

instalado docker no wsl, rodar o docker compose up -d na api do pizzashop
-d p rodar em modo detached, nao fica rodando no terminal pra precisar manter o terminal aberto

bun i 
bun migrate (RESEND_API_KEY=".") 


------------------------------------------

vamos fazer o api client, o cliente que vamos usar no frontend pra se comunicar com o backend

AXIOS


axios.ts - criar a api, mas a url nao pode ser estatica

.env.local - VITE_API_URL=""
variavel ambiente tem que comecar com VITE_ no vite


no axios, a baseURL: ficaria import.meta.env...
mas dessa forma, nao temos validacao das variaveis de ambiuente

-> criar um env.ts no src
faz validacao com zod.

agora, no axios, colocar 
baseURL: env.VITE_API_URL,

dessa forma, o parse vai validar que aquele meta.en tem a mesma estrutura
daquele schema que fizemos


REACT-QUERY
- hooks pra facilitar requisicoes entre front e back
- ferramenta fantastica

-> criar react-query.ts p exportar o client

-> jogar esse client no app.tsx, antes das rotas
(antes das rotas pois provavelmente n usaremos em outros lugares)
passando aquele queryClient que fizemos no react-query.ts

<QueryClientProvider client={queryClient}>
          <RouterProvider router={router} />
</QueryClientProvider>


----------------------------------------------------------------

AUTENTICACAO
no sign-in, no processo de login, estamos apenas fazendo um delay e dps
mandando um toast de success.
-vms manter o maximo possivel das comunicacaos feitas entre front e 
back tipadas, isso permite que saibemos exatamente qausi sao os dados 
retornados de tal requisicao. 
Vamos fazer manualmente, apesar de ter ferramentas que fazem isso de forma
automatizada, como trpc ou graphql.

fazer uma pasta API no src, fazer um arquivo pra cada rota, por ex:
sign-in.ts com a funcao que esta encapsulando o axios e com tipagem
APENAS o tipo de entrada ( email), pois no caso da rota authenticate, nao
ha retorno (saida)


ao fazer signIn no sign-in.ts com a rota authenticate, 

reactquery tem o useMutation, usaremos sempre que fizermos uma mutacao,
que eh qualquer acao que nao seja de listagem, ou de retorno.

se estamos criando algo, todo post, put, delete, eh uma mutation.
um get eh uma query.

esse useMutation nos da acesso a varias funcionalidades,
retry, networkdMode, onError, onSuccess.

o useMutation tbm retorna varias informacoes 

const { mutateAsync: authenticate } = useMutation({
    mutationFn: signIn,
  })

  por exemplo, esse mutateSync, que renomeamos para authenticate.
  tbm podemos saber quando o usuario chamou essa requisicao,
  qual o status, isSuccess, isError, isIdle, isPending, isPause, etc.

  o mutationAsync vamos usar para chamamr a funcao signIn.
  mutationAsync eh uma funcao. chamando esse mutationAsync, vamos
  disparar aquela funcao no mutationFn, que eh a signIn.

  await mutationAsync({ email: data.email })
  como renomeamos,:
  await authenticate({ email: data.email })
  renomeamos para authenticate pois podemos ter varias mutations no mesmo arquivo.

  Agora podemos fazer nosso primeiro teste de integracao com a API.
  primeiro integramos o metodo de autenticacao, da rota authenticate com axios.

  ao colocar o email que ta cadastrado la no backend ao rodar o bun seed 
  la no painel de sign-in do front end, ao clicarmos, vai aparecer o toast
  de sucesso.

  no browser, inspecionar, networkd(rede), podemos filtrar para apenas "Fetch/XHR",
  pra visualizar apenas as requisicoes ao backend

  aparece la que foi disparado o authenticate, podemos clicar e ver as
  informacoes daquela requisicao, o cabecalho, o payload,repsonse, etc.

  no backend ta configurado pra dar apenas um console.log no link que seria 
  mandado para o email do usuario, para, ao clicar nesse link, entrar no site 
  de forma logada, o tal do magic link, passwordless. 

  Quando entra por esse link, seremos autenticados e redirecionados de volta pro
  frontend.
  A diferenca eh que nesse front-end, ha um cookie salvo no navegador, JWT,
  que foi salvo la pelo backend.
  o backend salvou esse cookie como httpOnly, que faz com que esse cookie nao seja acessivel
  pelas apis do browser, pelo document. (n da p fzr document.cookie). Essse cookie
  so ta visivel no backend da aplicacao.
  Isso eh seguro pois extensoes instalada sno navegador nao sejam acessiveis a esse cookie.


----------------------------------------------------------------
CADASTRO DE Restaurante

-> fazer a funcaozinha de axios la na pasta api.

-> no signUp, pegar mutateAsync do useMutation novamente para chamar 
o registerRestaurant que fizemos la no register-restaurants.ts na pasta api.
obviamente mandando os valores do form , que foram especificados na interface feita
pelo zod.

-> ao criarmos, fazer a requisicao, e dar sucesso, estamos mandando ali o toast
com um botao para navegacao para o /sing-in

onClick: () => navigate('/sign-in'),

vamos mandar pra esse sign-in, um query parameter.

onClick: () => navigate(`/sign-in?email=${data.email}`),

mandando exatamente o mesmo email que ele acabou de se cadastrar, que ainda esta ali
no data: SignUpForm do handleSignUp.

e VAMOS PEGAR ESSE EMAIL la no sign-in usando useSearchParams do react-router-dom

const [searchParams] = useSearchParams()
eh como se fosse um useState, a primeira posicao do array retorna os search parameters
da url, e na segunda posicao, uma funcao p atualizar esses parametros.

vamos acessar apenas o primeiro, entao vamos desestruturar: [searchParams]

e no useForm, vamos colocar um defaultValues e vamos setar para que NO campo email,
caso nao seja nulo o searchParams.get('email'), vamos ja colocar esse defaultvalue para
quando o usuario for p essa pagina depois de fazer o cadastro (sign-up), ja esteja ali
escrito o email que ele acabou de criar.